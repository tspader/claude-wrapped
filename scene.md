# Scene System Plan

## Goal
Load actual scenes into WASM raymarcher. Scene data flows from TS definition → flat arrays → WASM evaluation.

## Architecture

```
Each Frame:
1. SceneDefinition (static structure)
     ↓
2. animation(t, basePosition) per object → current positions
     ↓
3. compileScene(def, t) → FlatScene (typed arrays)
     ↓
4. Copy to WASM buffers
     ↓
5. march_rays()
     ↓
6. Read colors, render to terminal
```

## Phase 1: Define Scene Data Format

C code receives:
```c
uint8_t* types;      // SDF_SPHERE=0, SDF_BOX=1, etc.
float* params;       // shape params (radius for sphere, w/h/d for box)
float* positions;    // x,y,z center per shape
float* colors;       // r,g,b per shape
uint32_t count;      // number of shapes
float smooth_k;      // smooth union factor
```

**Checkpoint 1:** Add `set_scene()` API to C, hardcode test call from JS with 3 spheres at different positions/colors, verify it renders.

## Phase 2: Scene Compilation in TypeScript

Create function to flatten scene to typed arrays:
```ts
function compileScene(scene: SceneDefinition, t: number): FlatScene
```

**Checkpoint 2:** Compile JS scene to flat arrays, log them, verify correctness.

## Phase 3: Pass Scene to WASM

- Copy compiled scene arrays to WASM buffers
- Call `march_rays()` with dynamic scene

**Checkpoint 3:** Render actual blob columns + Claude scene through WASM.

## Phase 4: Animation Support

- Keep animation logic in JS
- Recompile scene to flat arrays each frame
- Only SDF evaluation in WASM

**Checkpoint 4:** Animated scene works.

## Design Decisions

### Smooth Union
- All shapes smooth-unioned together (current behavior)
- Single `smooth_k` parameter

### Transforms
- JS computes final world positions
- C receives pre-transformed positions (no matrices in WASM)

### Claude Model
- Flatten to 7 separate boxes in scene array
- Each box has its own position/dimensions/color

---

## Data-Driven Scene Format

```ts
// Shape types (match C enum)
const ShapeType = {
  SPHERE: 0,
  BOX: 1,
} as const;

// A single shape definition
interface ShapeDef {
  type: number;           // ShapeType
  params: number[];       // [radius] for sphere, [w,h,d] for box
  color: Vec3;
}

// An object in the scene (shape + placement + animation)
interface ObjectDef {
  shape: ShapeDef;
  position: Vec3;                               // base position
  animation?: (t: number, base: Vec3) => Vec3;  // optional position animation
}

// Full scene definition
interface SceneDefinition {
  objects: ObjectDef[];
  smoothK: number;
  camera?: Partial<CameraConfig>;
}
```

### Example: Test Scene
```ts
const testScene: SceneDefinition = {
  objects: [
    {
      shape: { type: ShapeType.SPHERE, params: [1.2], color: [0.4, 0.6, 0.5] },
      position: [-1.5, 0, 0],
    },
    {
      shape: { type: ShapeType.SPHERE, params: [1.2], color: [0.4, 0.6, 0.5] },
      position: [1.5, 0, 0],
    },
  ],
  smoothK: 0.8,
};
```

### Example: Blob Columns
```ts
const blobScene: SceneDefinition = {
  objects: [
    // Left column (4 spheres)
    ...Array.from({ length: 4 }, (_, i) => ({
      shape: { type: ShapeType.SPHERE, params: [1.8], color: [0.388, 0.627, 0.533] },
      position: [-8, -5.25 + i * 3.5, 0] as Vec3,
      animation: (t: number, base: Vec3) => driftAnimation(t, base, noiseOffset[i]),
    })),
    // Right column (4 spheres) - same pattern
    // Claude (7 boxes) - generated by helper
  ],
  smoothK: 2.0,
};
```

### Compile to WASM Format
```ts
function compileScene(def: SceneDefinition, t: number): FlatScene {
  const n = def.objects.length;
  const types = new Uint8Array(n);
  const params = new Float32Array(n * 4);  // max 4 params per shape
  const positions = new Float32Array(n * 3);
  const colors = new Float32Array(n * 3);

  for (let i = 0; i < n; i++) {
    const obj = def.objects[i];
    const pos = obj.animation ? obj.animation(t, obj.position) : obj.position;
    
    types[i] = obj.shape.type;
    params.set(obj.shape.params, i * 4);
    positions.set(pos, i * 3);
    colors.set(obj.shape.color, i * 3);
  }

  return { types, params, positions, colors, count: n, smoothK: def.smoothK };
}
```

## Performance Notes

**Cheap (JS):**
- Animation functions: simple math (noise, sin, easing)
- Compiling scene: O(n) where n ≈ 15 shapes
- Copying to WASM: `typedArray.set()`

**Expensive (WASM+SIMD):**
- SDF evaluation: O(rays × steps × shapes) ≈ 10k × 32 × 15 = 4.8M evals/frame

## Scene State

Animation state (RNG seeds, noise offsets) initialized once at scene creation:
```ts
function createBlobScene(seed: number): SceneDefinition {
  const rng = seededRandom(seed);
  const noiseOffsets = generateNoiseOffsets(rng, 8);
  
  return {
    objects: [...],  // closures capture noiseOffsets
    smoothK: 2.0,
  };
}
```

## Files

- `src/wasm/renderer.c` - WASM raymarcher with `set_scene()` API
- `src/scene.ts` - SceneDefinition types and scene constructors  
- `src/main-wasm.ts` - compileScene() and render loop
